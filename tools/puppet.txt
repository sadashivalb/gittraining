http://www.6tech.org/2013/01/how-to-install-puppet-open-source-on-centos-6-3/
puppet agent --test
https://downloads.puppetlabs.com/windows/

Puppet
======
Puppet Enterprise
MCollective
Puppet Dashboard
PuppetDB
Hiera
Facter
Community
Help Improve This Site
Documentation Version

Files - Puppet language files are called manifests, and are named with the .pp file extension.
Compilation and Catalogs
Puppet compiles manifests into a catalog, which is only valid for a single
node and which contains no ambiguous logic.
a catalog will be in memory as a Ruby object, transmitted as JSON, and
persisted to disk as YAML. The catalog format used by this version of Puppet
is not documented and does not have a spec.
If they request a catalog and the master fails to compile one, they will
re-use their cached catalog(puppet.conf)
Ordering

Puppet’s language is mostly declarative: 
Acceptable Characters in Names
Variables
Classes and Types
Modules
Parameters
Tags
Resources
Nodes

Resources
=========
Resources are the fundamental unit for modeling system configurations.

Syntax

# A resource declaration:
file { '/etc/passwd':
        ensure => file,
        owner  => 'root',
        group  => 'root',
        mode   => '0600',
    }

The general form of a resource declaration is:

The resource type, in lower-case
An opening curly brace
The title, which is a string
A colon
Optionally, any number of attribute and value pairs, each
of which consists of:
An attribute name, which is a bare word
A => (arrow, fat comma, or hash rocket)
A value, which can be any data type, depending on what the attribute requires A trailing comma (note
that the comma is optional after the final attribute/value pair) Optionally, a semicolon, followed by
another title, colon, and attribute block A closing curly brace Note that, in the Puppet language,
whitespace is fungible.

Relationships and Ordering
==========================
    package { 'openssh-server':
      ensure => present,
      before => File['/etc/ssh/sshd_config'],
    }

    file { '/etc/ssh/sshd_config':
      ensure  => file,
      mode    => 600,
      source  => 'puppet:///modules/sshd/sshd_config',
      require => Package['openssh-server'],
    }

Refresh- refreshonly => true or refresh

Resource Defaults
=================
 Exec {
        path        => '/usr/bin:/bin:/usr/sbin:/sbin',
        environment => 'RUBYLIB=/opt/puppet/lib/ruby/site_ruby/1.8/',
        logoutput   => true,
        timeout     => 180,
    }

Variables

$a = "Sada\n"
Reassignment - Unlike most other languages, Puppet only allows a given
variable to be assigned once within a given scope.

Scope
=====
# site.pp
$variable = "Hi!"
class example {
notify {"Message from elsewhere: $variable":}
}
include example
#puppet apply site.pp
puppet apply -e 'notify { foo:message => "Hello word!"}'

Conditional Statements
======================
Puppet 3 supports “if” and “unless” statements, case statements, and selectors.
    if $is_virtual == 'true' {
      warning('Tried to include class ntp on virtual machine; this node may be misclassified.')
    }
    elsif $operatingsystem == 'Darwin' {
      warning('This NTP module does not yet work on our Mac laptops.')
    }
    else {
      include ntp
    }

#“Unless” statements work like reversed “if” statements.
unless $memorysize > 1024 {
      $maxclient = 500
    }

case $operatingsystem {
      'Solaris':          { include role::solaris }
      'RedHat', 'CentOS': { include role::redhat  }
      /^(Debian|Ubuntu)$/:{ include role::debian  }
      default:            { include role::generic }
    }
Selector statements are similar to case statements, but return a value instead
of executing a code block.

$rootgroup = $osfamily ? {
        'Solaris'          => 'wheel',
        /(Darwin|FreeBSD)/ => 'wheel',
        default            => 'root',
    }

    file { '/etc/passwd':
      ensure => file,
      owner  => 'root',
      group  => $rootgroup,
    }

Expressions
===========
Operators
Boolean Operators
Airthmatic

Classes
=======
Classes are named blocks of Puppet code, which are stored in modules for later use and are not applieduntil they are 
invoked by name.

require/include

# A class with no parameters
    class base::linux {
      file { '/etc/passwd':
        owner => 'root',
        group => 'root',
        mode  => '0644',
      }
      file { '/etc/shadow':
        owner => 'root',
        group => 'root',
        mode  => '0440',
      }
    }

The general form of a class definition is:

The class keyword
The name of the class
An optional set of parameters, which consists of:
An opening parenthesis
A comma-separated list of parameters, each of which consists of:
A new variable name, including the $ prefix
An optional equals (=) sign and default value (any data type)
An optional trailing comma after the last parameter
A closing parenthesis
Optionally, the inherits keyword followed by a single class name
An opening curly brace
A block of arbitrary Puppet code, which generally contains at least one resource declaration
A closing curly brace

You can remove an attribute’s previous value without setting a new one by
overriding it with the special value undef:
you can add to the existing values instead of replacing them by using the +>
(“plusignment”) keyword instead of the standard => hash rocket:

Defined Resource Types
======================

# /etc/puppetlabs/puppet/modules/apache/manifests/vhost.pp
    define apache::vhost ($port, $docroot, $servername = $title, $vhost_name = '*') {
      include apache # contains Package['httpd'] and Service['httpd']
      include apache::params # contains common config settings
      $vhost_dir = $apache::params::vhost_dir
      file { "${vhost_dir}/${servername}.conf":
        content => template('apache/vhost-default.conf.erb'), 
          # This template can access all of the parameters and variables from above.
        owner   => 'www',
        group   => 'www',
        mode    => '644',
        require => Package['httpd'],
        notify  => Service['httpd'],
      }
    }

Node Defintion
==============

Node definitions should go in the site manifest (site.pp).
# /etc/puppetlabs/puppet/manifests/site.pp
# Import every file in /etc/puppetlabs/puppet/manifests/nodes/
# (Usually, each file contains one node definition.)
import 'nodes/*.pp'
# Import several nodes from a single file
import 'extra_nodes.pp'
syntax
node "wwe.example.com"{
    include apache
}


Challenge

You want to install a package
Solution

package { "screen":
    ensure => "installed" or ensure => "latest"
    }


you want to install multiple packages
package { "screen": ensure => "installed" }
package { "strace": ensure => "installed" }
or 
# you can use a global package parameter
Package { ensure => "installed" }

package { "screen": } 
package { "strace": }

You want to remove a package
Solution

# remove a package but leave its config files alone
package { "screen":
    ensure => "absent"
    }

    # remove a package and purge its config files
    package { "screen":
        ensure => "purged"
        }

You want to change the default package provider for your systems
# in your site.pp
Package { provider => "aptrpm" }

You want to install a Ruby Gem
Solution

package { 'sinatra':
    ensure   => 'installed',
        provider => 'gem',
        }

File:
You want to create a new directory
Solution

# create a directory
file { "/etc/site-conf":
    ensure => "directory",
    }

    # a fuller example, including permissions and ownership
    file { "/var/log/admin-app-log":
        ensure => "directory",
        owner  => "root",
        group  => "wheel",
        mode   => 750,
      }

    # this example is incorrect and creates a file
    file { "/etc/site-conf/":
            ensure => "present",
         }

You want to create a new directory tree
Solution

# create a directory tree, list the directories in order
# and puppet will "do the right thing".
file { [ "/usr/local/whisper/", "/usr/local/whisper/2.0",
         "/usr/local/whisper/2.0/bin", "/usr/local/whisper/2.0/log" ]:
    ensure => "directory",
}

# or you can assign them to a variable and use them in the resource
$whisper_dirs = [ "/usr/local/whisper/", "/usr/local/whisper/2.0",
                  "/usr/local/whisper/2.0/bin", "/usr/local/whisper/2.0/log",
                ]

file { $whisper_dirs:
    ensure => "directory",
    owner  => "root",
    group  => "wheel",
    mode   => 750,
}

# doesn't work - will fail unless whisper and 2.0 already exist
file { "/usr/local/whisper/2.0/bin":
  ensure => "directory",
}

You want to create a symlink using puppet.
Solution

# preferred symlink syntax
file { '/tmp/link-to-motd':
   ensure => 'link',
   target => '/etc/motd',
}

You want to deploy a specific file based on the value of a fact.
Solution

file { "/etc/mysql/conf.d/tuning.cnf":
    ensure => "present",
    source => [
        "puppet:///modules/mysql-server/tuning.$hostname.cnf",
        "puppet:///modules/mysql-server/tuning.$domain.cnf",
        "puppet:///modules/mysql-server/tuning.cnf"
    ],
}

Only add a file if it’s absent.
You only want puppet to add a file if the file isn’t already present. Once it’s added, or if it’s already there, you want to leave it alone.
Solution

file { "/tmp/hello-file":
    replace => "no", # this is the important property
    ensure  => "present",
    content => "From Puppet\n",
    mode    => 644,
}

You want to restart a service when its config file changes
Solution

# define the service to restart
service { "sshd":
    ensure  => "running",
    enable  => "true",
    require => Package["openssh-server"],
}

# add a notify to the file resource
file { "/etc/ssh/sshd_config":
    notify  => Service["sshd"],  # this sets up the relationship
    mode    => 600,
    owner   => "root",
    group   => "root",
    require => Package["openssh-server"],
    content => template("ssh/sshd_config.erb"),
}

Reduce Duplicated File Attributes
Challenge
Using the template
You’ve had enough of specifying owner, mode, group and other settings on every file resource and you want a solution with less duplication
Solution

File {
  ensure => "present",
  owner  => "root",
  group  => "root",
  mode   => 644,
}

file { "/etc/cobbler/modules.conf":
  content => template("cobbler/modules.conf"),
}

file { "/etc/cobbler/dhcp.template":
  content => template("cobbler/dhcp.template"),
}

# create a simple hostname and ip host entry
host { 'syslog':
    ip => '10.10.10.10',
}

# create a fully qualified full host entry with an alias
host { 'ntpserver.example.com':
    ip => '10.100.10.50',
    host_aliases => 'timeserver',
}

# host entry with multiple aliases
host { 'dashboard':
    ip => '10.120.100.111',
    host_aliases => [ 'nagios', 'munin' ],
}

Remove a host entry
Solution

host { 'syslog':
    ensure => "absent",
}

host { 'ntpserver.example.com':
    ensure => "absent",
}

Remove all unmanaged host entries

# always test with noop first!
resources { 'host':
    purge => true,
    noop => true,
}

# remove ALL unmanaged host resources
resources { 'host': purge => true }

Adding a per-domain hostname

host { "syslog":
    ip => $domain ? {
        /production/ => "10.10.10.10",
        /staging/    => "192.168.23.10",
        default      => "10.100.100.100",
    }
}


exec { "refresh_cache":
    command => "refresh_cache 8600",
    path    => "/usr/local/bin/:/bin/",
    # path    => [ "/usr/local/bin/", "/bin/" ],  # alternative syntax

You want to set a default $PATH for all execs

Solution

# put this somewhere global, like site.pp
Exec { path => [ "/bin/", "/sbin/" , "/usr/bin/", "/usr/sbin/" ] }

# uses the globally specified path
exec { "make_foo_state":
    command => "mkdir -p /tmp/foo/state",
}

# overrides the global path for this command
exec { "my_local_command":
    command => "my_special_local_command",
    path    => "/usr/local/sbin/",
}
}

You’d like nicer names for your exec resources

# exec with the command as the name
exec { "/bin/mkdir -p /tmp/needed/directory":
}

package { "needed":
    ensure  => "installed",
    # awkward, long require
    require => Exec["/bin/mkdir -p /tmp/needed/directory"],
}

# nicer, human friendly naming
exec { "create_needed_directory":
    command => "/bin/mkdir -p /tmp/needed/directory",
}

package { "needed":
    ensure  => "installed",
    # easier to read require
    require => Exec["create_needed_directory"],
}

Don’t run exec if $file exists
exec { "create_needed_directory":
    command => "/bin/mkdir -p /tmp/needed/directory",
    creates => "/tmp/needed/directory"
}

Selective exec running

# run exec only if command in onlyif returns 0.
exec { "run_account_purger":
    command => "/usr/local/sbin/account_purger",
    onlyif => "grep -c old_account /etc/passwd",
}

# or run multiple commands - all must succeed for exec to run
exec { "run_account_purger":
    command => "/usr/local/sbin/account_purger",
    onlyif => [
                "grep -c old_account /etc/passwd",
                "test -d /home/old_account/"
              ]
}

Logging an Execs output

# on_failure logs the commands output on failure
exec { "delete_str_tmp":
    path    => "/usr/local/bin/:/bin:/usr/sbin",
    command => 'find /tmp/ -name "*.str" -type f | xargs -n 1 rm',
    logoutput => "on_failure",
}

# on_failure logs the commands output on failure
exec { "delete_str_tmp":
    path    => "/usr/local/bin/:/bin:/usr/sbin",
    command => 'find /tmp/ -name "*.str" -type f | xargs -n 1 rm',
    logoutput => "on_failure",
}

